python.data-structure
=========================
dictionary
^^^^^^^^^^

.. note::

    Tags: :doc:`python.data-structure <python.data-structure>`

    Support Level: SUPPORTED

Original source code:

.. code-block:: python

    # mypy: allow-untyped-defs
    import torch
    
    class Dictionary(torch.nn.Module):
        """
        Dictionary structures are inlined and flattened along tracing.
        """
    
        def forward(self, x, y):
            elements = {}
            elements["x2"] = x * x
            y = y * elements["x2"]
            return {"y": y}
    
    example_inputs = (torch.randn(3, 2), torch.tensor(4))
    tags = {"python.data-structure"}
    model = Dictionary()
    

Result:

.. code-block::

    ExportedProgram:
        class GraphModule(torch.nn.Module):
            def forward(self, x: "[31mf32[0m[34m[3, 2][0m[2m[34m[0m[2m[32m[0m", y: "[31mi64[0m[34m[][0m[2m[34m[0m[2m[32m[0m"):
                 [2m# File: /opt/conda/envs/py_3.8/lib/python3.8/site-packages/torch/_export/db/examples/dictionary.py:11 in forward, code: elements["x2"] = x * x[0m
                mul: "[31mf32[0m[34m[3, 2][0m[2m[34m[0m[2m[32m[0m" = torch.ops.aten.mul.Tensor(x, x);  [2mx = None[0m
                
                 [2m# File: /opt/conda/envs/py_3.8/lib/python3.8/site-packages/torch/_export/db/examples/dictionary.py:12 in forward, code: y = y * elements["x2"][0m
                mul_1: "[31mf32[0m[34m[3, 2][0m[2m[34m[0m[2m[32m[0m" = torch.ops.aten.mul.Tensor(y, mul);  [2my = mul = None[0m
                return (mul_1,)
                
    Graph signature: ExportGraphSignature(input_specs=[InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='x'), target=None, persistent=None), InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='y'), target=None, persistent=None)], output_specs=[OutputSpec(kind=<OutputKind.USER_OUTPUT: 1>, arg=TensorArgument(name='mul_1'), target=None)])
    Range constraints: {}
    


fn_with_kwargs
^^^^^^^^^^^^^^

.. note::

    Tags: :doc:`python.data-structure <python.data-structure>`

    Support Level: SUPPORTED

Original source code:

.. code-block:: python

    # mypy: allow-untyped-defs
    import torch
    
    from torch._export.db.case import ExportArgs
    
    class FnWithKwargs(torch.nn.Module):
        """
        Keyword arguments are not supported at the moment.
        """
    
        def forward(self, pos0, tuple0, *myargs, mykw0, **mykwargs):
            out = pos0
            for arg in tuple0:
                out = out * arg
            for arg in myargs:
                out = out * arg
            out = out * mykw0
            out = out * mykwargs["input0"] * mykwargs["input1"]
            return out
    
    example_inputs = ExportArgs(
        torch.randn(4),
        (torch.randn(4), torch.randn(4)),
        *[torch.randn(4), torch.randn(4)],
        mykw0=torch.randn(4),
        input0=torch.randn(4), input1=torch.randn(4)
    )
    tags = {"python.data-structure"}
    model = FnWithKwargs()
    

Result:

.. code-block::

    ExportedProgram:
        class GraphModule(torch.nn.Module):
            def forward(self, pos0: "[31mf32[0m[34m[4][0m[2m[34m[0m[2m[32m[0m", tuple0_0: "[31mf32[0m[34m[4][0m[2m[34m[0m[2m[32m[0m", tuple0_1: "[31mf32[0m[34m[4][0m[2m[34m[0m[2m[32m[0m", myargs_0: "[31mf32[0m[34m[4][0m[2m[34m[0m[2m[32m[0m", myargs_1: "[31mf32[0m[34m[4][0m[2m[34m[0m[2m[32m[0m", mykw0: "[31mf32[0m[34m[4][0m[2m[34m[0m[2m[32m[0m", input0: "[31mf32[0m[34m[4][0m[2m[34m[0m[2m[32m[0m", input1: "[31mf32[0m[34m[4][0m[2m[34m[0m[2m[32m[0m"):
                 [2m# File: /opt/conda/envs/py_3.8/lib/python3.8/site-packages/torch/_export/db/examples/fn_with_kwargs.py:14 in forward, code: out = out * arg[0m
                mul: "[31mf32[0m[34m[4][0m[2m[34m[0m[2m[32m[0m" = torch.ops.aten.mul.Tensor(pos0, tuple0_0);  [2mpos0 = tuple0_0 = None[0m
                mul_1: "[31mf32[0m[34m[4][0m[2m[34m[0m[2m[32m[0m" = torch.ops.aten.mul.Tensor(mul, tuple0_1);  [2mmul = tuple0_1 = None[0m
                
                 [2m# File: /opt/conda/envs/py_3.8/lib/python3.8/site-packages/torch/_export/db/examples/fn_with_kwargs.py:16 in forward, code: out = out * arg[0m
                mul_2: "[31mf32[0m[34m[4][0m[2m[34m[0m[2m[32m[0m" = torch.ops.aten.mul.Tensor(mul_1, myargs_0);  [2mmul_1 = myargs_0 = None[0m
                mul_3: "[31mf32[0m[34m[4][0m[2m[34m[0m[2m[32m[0m" = torch.ops.aten.mul.Tensor(mul_2, myargs_1);  [2mmul_2 = myargs_1 = None[0m
                
                 [2m# File: /opt/conda/envs/py_3.8/lib/python3.8/site-packages/torch/_export/db/examples/fn_with_kwargs.py:17 in forward, code: out = out * mykw0[0m
                mul_4: "[31mf32[0m[34m[4][0m[2m[34m[0m[2m[32m[0m" = torch.ops.aten.mul.Tensor(mul_3, mykw0);  [2mmul_3 = mykw0 = None[0m
                
                 [2m# File: /opt/conda/envs/py_3.8/lib/python3.8/site-packages/torch/_export/db/examples/fn_with_kwargs.py:18 in forward, code: out = out * mykwargs["input0"] * mykwargs["input1"][0m
                mul_5: "[31mf32[0m[34m[4][0m[2m[34m[0m[2m[32m[0m" = torch.ops.aten.mul.Tensor(mul_4, input0);  [2mmul_4 = input0 = None[0m
                mul_6: "[31mf32[0m[34m[4][0m[2m[34m[0m[2m[32m[0m" = torch.ops.aten.mul.Tensor(mul_5, input1);  [2mmul_5 = input1 = None[0m
                return (mul_6,)
                
    Graph signature: ExportGraphSignature(input_specs=[InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='pos0'), target=None, persistent=None), InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='tuple0_0'), target=None, persistent=None), InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='tuple0_1'), target=None, persistent=None), InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='myargs_0'), target=None, persistent=None), InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='myargs_1'), target=None, persistent=None), InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='mykw0'), target=None, persistent=None), InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='input0'), target=None, persistent=None), InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='input1'), target=None, persistent=None)], output_specs=[OutputSpec(kind=<OutputKind.USER_OUTPUT: 1>, arg=TensorArgument(name='mul_6'), target=None)])
    Range constraints: {}
    


list_contains
^^^^^^^^^^^^^

.. note::

    Tags: :doc:`torch.dynamic-shape <torch.dynamic-shape>`, :doc:`python.data-structure <python.data-structure>`, :doc:`python.assert <python.assert>`

    Support Level: SUPPORTED

Original source code:

.. code-block:: python

    # mypy: allow-untyped-defs
    import torch
    
    class ListContains(torch.nn.Module):
        """
        List containment relation can be checked on a dynamic shape or constants.
        """
    
        def forward(self, x):
            assert x.size(-1) in [6, 2]
            assert x.size(0) not in [4, 5, 6]
            assert "monkey" not in ["cow", "pig"]
            return x + x
    
    example_inputs = (torch.randn(3, 2),)
    tags = {"torch.dynamic-shape", "python.data-structure", "python.assert"}
    model = ListContains()
    

Result:

.. code-block::

    ExportedProgram:
        class GraphModule(torch.nn.Module):
            def forward(self, x: "[31mf32[0m[34m[3, 2][0m[2m[34m[0m[2m[32m[0m"):
                 [2m# File: /opt/conda/envs/py_3.8/lib/python3.8/site-packages/torch/_export/db/examples/list_contains.py:13 in forward, code: return x + x[0m
                add: "[31mf32[0m[34m[3, 2][0m[2m[34m[0m[2m[32m[0m" = torch.ops.aten.add.Tensor(x, x);  [2mx = None[0m
                return (add,)
                
    Graph signature: ExportGraphSignature(input_specs=[InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='x'), target=None, persistent=None)], output_specs=[OutputSpec(kind=<OutputKind.USER_OUTPUT: 1>, arg=TensorArgument(name='add'), target=None)])
    Range constraints: {}
    


list_unpack
^^^^^^^^^^^

.. note::

    Tags: :doc:`python.data-structure <python.data-structure>`, :doc:`python.control-flow <python.control-flow>`

    Support Level: SUPPORTED

Original source code:

.. code-block:: python

    # mypy: allow-untyped-defs
    from typing import List
    
    import torch
    
    class ListUnpack(torch.nn.Module):
        """
        Lists are treated as static construct, therefore unpacking should be
        erased after tracing.
        """
    
        def forward(self, args: List[torch.Tensor]):
            """
            Lists are treated as static construct, therefore unpacking should be
            erased after tracing.
            """
            x, *y = args
            return x + y[0]
    
    example_inputs = ([torch.randn(3, 2), torch.tensor(4), torch.tensor(5)],)
    tags = {"python.control-flow", "python.data-structure"}
    model = ListUnpack()
    

Result:

.. code-block::

    ExportedProgram:
        class GraphModule(torch.nn.Module):
            def forward(self, args_0: "[31mf32[0m[34m[3, 2][0m[2m[34m[0m[2m[32m[0m", args_1: "[31mi64[0m[34m[][0m[2m[34m[0m[2m[32m[0m", args_2: "[31mi64[0m[34m[][0m[2m[34m[0m[2m[32m[0m"):
                 [2m# File: /opt/conda/envs/py_3.8/lib/python3.8/site-packages/torch/_export/db/examples/list_unpack.py:18 in forward, code: return x + y[0][0m
                add: "[31mf32[0m[34m[3, 2][0m[2m[34m[0m[2m[32m[0m" = torch.ops.aten.add.Tensor(args_0, args_1);  [2margs_0 = args_1 = None[0m
                return (add,)
                
    Graph signature: ExportGraphSignature(input_specs=[InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='args_0'), target=None, persistent=None), InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='args_1'), target=None, persistent=None), InputSpec(kind=<InputKind.USER_INPUT: 1>, arg=TensorArgument(name='args_2'), target=None, persistent=None)], output_specs=[OutputSpec(kind=<OutputKind.USER_OUTPUT: 1>, arg=TensorArgument(name='add'), target=None)])
    Range constraints: {}
    
